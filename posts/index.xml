<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Avatar&#39;s Blog</title>
    <link>http://blog.ryune.top/posts/</link>
    <description>Recent content in Posts on Avatar&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 14 Jul 2019 23:21:09 +0800</lastBuildDate>
    
	<atom:link href="http://blog.ryune.top/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Redis: 互斥锁</title>
      <link>http://blog.ryune.top/posts/redis-mutex/</link>
      <pubDate>Sun, 14 Jul 2019 23:21:09 +0800</pubDate>
      
      <guid>http://blog.ryune.top/posts/redis-mutex/</guid>
      <description>基于 SETNX
  SETNX: set if not exists 如果不存在，则 SET 成功返回1，失败返回0   v1.0 // 伪代码 获取锁： setnx key value expire key expiration 释放锁： del key   特点：加过期时间避免异常导致锁无法释放的情况 缺点：expire key expiration 执行前异常，依然存在锁无法过期的问题  v1.1 // 伪代码 获取锁： 过期时间戳=当前时间戳+过期时间 setnx key 过期时间戳 如果获取锁失败，则通过 get key 检查该锁的过期时间戳是否已过期 getset key 过期时间戳 修改该锁的过期时间戳为当前过期时间戳 检查 getset 返回的该锁旧的过期时间戳 如果与上一条 get 获取的该锁的过期时间戳相等，则获取锁成功 释放锁： del key   特点：锁未加过期时间 缺点：  并发有可能导致该锁的过期时间戳被不停的覆盖，谁都拿不到锁 获取到锁的进程异常导致未释放，锁的过期时间被其他进程修改，从而延长等待时间   v2.</description>
    </item>
    
    <item>
      <title>Golang 基础：map</title>
      <link>http://blog.ryune.top/posts/golang-map/</link>
      <pubDate>Thu, 11 Jul 2019 16:49:09 +0800</pubDate>
      
      <guid>http://blog.ryune.top/posts/golang-map/</guid>
      <description>map  无序 键值对集合 map 的传递不会拷贝副本，所以修改会影响所有该 map 的引用 如果要按顺序遍历 map  遍历 map，将所有 key 存入新 slice 对 slice 排序 遍历 slice，使用 map[key] 获取   package main import &amp;quot;fmt&amp;quot; func main() { // 无序 // 键值对集合 dict := map[string]int{&amp;quot;张三&amp;quot;: 1, &amp;quot;李四&amp;quot;: 2} fmt.Printf(&amp;quot;创建 dict: %T(%#v)\n&amp;quot;, dict, dict) for key, value := range dict { fmt.Printf(&amp;quot;无序 key: %#v, value: %#v\n&amp;quot;, key, value) } dict1 := map[int]string{1: &amp;quot;张三&amp;quot;, 2: &amp;quot;李四&amp;quot;} fmt.Printf(&amp;quot;创建 dict1: %T(%#v)\n&amp;quot;, dict1, dict1) for key, value := range dict1 { fmt.</description>
    </item>
    
    <item>
      <title>Golang 基础：slice</title>
      <link>http://blog.ryune.top/posts/golang-slice/</link>
      <pubDate>Thu, 11 Jul 2019 15:01:39 +0800</pubDate>
      
      <guid>http://blog.ryune.top/posts/golang-slice/</guid>
      <description>slice 底层基于数组实现
package main import &amp;quot;fmt&amp;quot; func main() { // 长度是5，容量也是5 slice := make([]int, 5) fmt.Printf(&amp;quot;slice: %T(%#v)\n&amp;quot;, slice, slice) // 长度是5，容量是10，容量必须 &amp;gt;= 长度，剩下5个需要扩充后才能访问 slice1 := make([]int, 5, 10) fmt.Printf(&amp;quot;slice1: %T(%#v)\n&amp;quot;, slice1, slice1) // 和创建数组很类似，不设置[]，会推导出来，并且长度和容量一致 slice2 := []int{ 4: 4, } fmt.Printf(&amp;quot;slice2: %T(%#v)\n&amp;quot;, slice2, slice2) // nil 切片：长度容量都是0，指向底层数组的指针为nil，表示一个不存在的切片 var slice3 []int fmt.Printf(&amp;quot;slice3: %T(%#v)\n&amp;quot;, slice3, slice3) // 空切片：长度容量都是0，表示一个空的切片 slice4 := []int{} fmt.Printf(&amp;quot;slice4: %T(%#v)\n&amp;quot;, slice4, slice4) // 基于现有的数组或切片创建 slice5 := slice2[:] fmt.Printf(&amp;quot;slice5: %T(%#v)\n&amp;quot;, slice5, slice5) slice6 := slice2[1:] fmt.</description>
    </item>
    
    <item>
      <title>Golang 基础：array</title>
      <link>http://blog.ryune.top/posts/golang-array/</link>
      <pubDate>Wed, 10 Jul 2019 21:21:09 +0800</pubDate>
      
      <guid>http://blog.ryune.top/posts/golang-array/</guid>
      <description>array  必须指定长度 传递数组指针修改数组内元素才有效  package main import &amp;quot;fmt&amp;quot; func main() { //var arr [5]int arr := [5]int{ 0: 1, } // 同类型，同长度才可相互赋值 // var arr1 [4]int // arr1 = arr fmt.Printf(&amp;quot;%T(%#v)\n&amp;quot;, arr, arr) fmt.Printf(&amp;quot;%T(%#v)\n&amp;quot;, arr[0], arr[0]) fmt.Printf(&amp;quot;%T(%#v)\n&amp;quot;, &amp;amp;arr[0], &amp;amp;arr[0]) for i, v := range arr { fmt.Printf(&amp;quot;索引:%d,值:%d\n&amp;quot;, i, v) } // 指针数组 ptrArr := [5]*int{ // 分配内存 1: new(int), // 其他索引为 nil } fmt.Printf(&amp;quot;%T(%#v)\n&amp;quot;, ptrArr, ptrArr) fmt.Printf(&amp;quot;%T(%#v)\n&amp;quot;, ptrArr[1], ptrArr[1]) fmt.</description>
    </item>
    
    <item>
      <title>OSS 踩坑</title>
      <link>http://blog.ryune.top/posts/oss-path/</link>
      <pubDate>Tue, 20 Mar 2018 23:21:09 +0800</pubDate>
      
      <guid>http://blog.ryune.top/posts/oss-path/</guid>
      <description> 路径错误  自定义的文件路径，key 不能以 / 开头！  OSSException in OSSExceptionFactory.php line 16: The specified object is not valid. </description>
    </item>
    
    <item>
      <title>Supervisor: 管理 Laravel Queue</title>
      <link>http://blog.ryune.top/posts/supervisor-1/</link>
      <pubDate>Tue, 05 Dec 2017 23:21:09 +0800</pubDate>
      
      <guid>http://blog.ryune.top/posts/supervisor-1/</guid>
      <description>安装 &amp;amp; 配置 安装
yum install supervisor  配置
# 文件路径 /etc/supervisord.conf vim /etc/supervisord.conf # 使用 unix [unix_http_server] file=/var/run/supervisor/supervisor.sock ; (the path to the socket file) ;chmod=0700 ; sockef file mode (default 0700) ;chown=nobody:nogroup ; socket file uid:gid owner ;username=user ; (default is no username (open server)) ;password=123 ; (default is no password (open server)) # 添加新任务的配置文件 [include] files=/etc/supervisord.d/conf.d/*.conf  管理 laravel 队列任务 # 新建配置文件 vim /etc/supervisord.d/conf.d/laravel-worker.conf # 编写配置 [program:laravel-worker] process_name=%(program_name)s_%(process_num)02d command=php /codtrade/CodtradeAPIServer/artisan queue:work database autostart=true autorestart=true user=nginx numprocs=8 redirect_stderr=true stdout_logfile=/var/log/supervisor/worker.</description>
    </item>
    
    <item>
      <title>测试: webbench</title>
      <link>http://blog.ryune.top/posts/test-webbench/</link>
      <pubDate>Mon, 31 Jul 2017 23:21:09 +0800</pubDate>
      
      <guid>http://blog.ryune.top/posts/test-webbench/</guid>
      <description> 1. 下载 wget http://home.tiscali.cz/cz210552/distfiles/webbench-1.5.tar.gz  2. 解压 tar xvzf webbench-1.5.tar.gz  3. 安装 gcc ctags yum install gcc ctags  4. 编译安装 make make install  5. 使用 // 并发500 30S测试 webbench -c 500 -t 300 http://localhost:61309/api/common/brands/2/subcategories-list/  </description>
    </item>
    
    <item>
      <title>Nginx: php-fpm 优化</title>
      <link>http://blog.ryune.top/posts/nginx-3/</link>
      <pubDate>Thu, 08 Dec 2016 23:21:09 +0800</pubDate>
      
      <guid>http://blog.ryune.top/posts/nginx-3/</guid>
      <description>php.ini # 关闭 php 信息显示 expose_php = Off # 最大执行时间 max_execution_time = 30 # POST data 最大值 post_max_size = 5M # 上传文件最大值 upload_max_filesize = 5M  php-fpm 启用多个 FPM 实例，提高处理效率。
cp www.conf 9000.conf cp php-fpm.conf php-fpm9000.conf ...  编辑 9000.conf
user = nginx group = nginx listen = /dev/shm/php-fpm9000.sock listen.backlog = 4096 listen.owner = nginx listen.group = nginx pm = static pm.max_children = 100 pm.max_requests = 2048 pm.status_path = /status9000 slowlog = /var/log/php-fpm/www-slow9000.</description>
    </item>
    
    <item>
      <title>Nginx: 多域名 HTTPS 配置</title>
      <link>http://blog.ryune.top/posts/nginx-2/</link>
      <pubDate>Fri, 02 Dec 2016 23:21:09 +0800</pubDate>
      
      <guid>http://blog.ryune.top/posts/nginx-2/</guid>
      <description>SSL Server Test  https://www.ssllabs.com/ssltest/index.html
 SNI  生成 dhparams.pem 文件
openssl dhparam -out /etc/nginx/ssl/dhparams.pem 2048  添加配置
ssl_dhparam /etc/nginx/ssl/dhparam.pem;   reverse-proxy.conf server { listen 80; if ($host = &#39;api.aaa.com&#39;) { return 301 https://api.aaa.com$request_uri; } if ($host = &#39;admin.aaa.com&#39;) { return 301 https://admin.aaa.com$request_uri; } if ($host = &#39;www.bbb.com&#39;) { return 301 https://www.bbb.com$request_uri; } return 301 http://www.aaa.com$request_uri; } # Admin Server server { listen 443; server_name admin.aaa.com; ssl on; ssl_certificate /etc/nginx/ssl/cert/admin.</description>
    </item>
    
    <item>
      <title>Nginx: php-fpm 配置</title>
      <link>http://blog.ryune.top/posts/nginx-1/</link>
      <pubDate>Sun, 20 Nov 2016 23:21:09 +0800</pubDate>
      
      <guid>http://blog.ryune.top/posts/nginx-1/</guid>
      <description>php-fpm 修改php.ini配置文件
cgi.fix_pathinfo=0  修改 php-pfm.d/www.conf
user = nginx group = nginx listen.owner = nobody listen.group = nobody  处理 Request # 根据 request 找到应该被 route 到哪一个 server. # 找不到就 route 到默认 server 上. # 默认 server 为第一个,也可以通过 default_server 参数设置. server { listen 80 default_server; server_name example.org www.example.org; ... } server { listen 80; server_name example.org www.example.org; ... } server { listen 80; server_name example.org www.example.org; ... } # 处理丢弃的 request server { listen 80; server_name &amp;quot;&amp;quot;; return 444; }  选择目录 server { listen 80; server_name example.</description>
    </item>
    
    <item>
      <title>Ubuntu: 完善-1</title>
      <link>http://blog.ryune.top/posts/ubuntu-1/</link>
      <pubDate>Mon, 26 Sep 2016 23:21:09 +0800</pubDate>
      
      <guid>http://blog.ryune.top/posts/ubuntu-1/</guid>
      <description> Ubuntu 16.04 WPS无法输入中文  安装搜狗linux
http://pinyin.sogou.com/linux/?r=pinyin  修改配置文件
 修改wps
vim /usr/bin/wps # 添加： export XMODIFIERS=&amp;quot;@im=fcitx&amp;quot; export QT_IM_MODULE=&amp;quot;fcitx&amp;quot;  修改et
vim /usr/bin/et # 添加 export XMODIFIERS=&amp;quot;@im=fcitx&amp;quot; export QT_IM_MODULE=&amp;quot;fcitx&amp;quot;    点击launcher图标最小化 gsettings set org.compiz.unityshell:/org/compiz/profiles/unity/plugins/unityshell/ launcher-minimize-window true  开启风扇 sudo find /sys | grep pwm echo 255 | sudo tee /sys/devices/platform/asus-nb-wmi/hwmon/hwmon3/pwm1  </description>
    </item>
    
  </channel>
</rss>